
A Stack is aÂ **Last In First Out(LIFO)**Â structure, i.e, the element that is added last in the stack is taken out first. Our goal is to implement a Stack using Queue for which will be using two queues and design them in such a way thatÂ **pop**Â operation is same as dequeue but theÂ **push**Â operation will be a little complex and more expensive too.

### ðŸ“Œ Inserting Data in Stack (using Queues)

- **Problem:**  
    Queue is **FIFO** (First In, First Out) but Stack is **LIFO** (Last In, First Out).  
    To make a **stack using queues**, we need to arrange elements so that the **latest pushed element** is always at the front of the queue.
    
- **Solution (using 2 Queues Q1 & Q2):**
    
    1. When `push(x)` is called:
        
        - Move all elements from **Q1 â†’ Q2**.
            
        - Add the new element `x` into **Q1**.
            
        - Move everything back from **Q2 â†’ Q1**.
            
    2. Now, the newest element (`x`) is at the **front** of Q1.
        
    3. So, when we do `pop()`, it will directly remove the latest pushed element â€” just like a stack!
        

---

ðŸ‘‰ In short:  
**Push operation rearranges the queue so that `pop()` always removes the last inserted element.**

![[Pasted image 20250901223801.png]]
**Code**
```java
import java.util.LinkedList;
import java.util.Queue;

class StackUsingQueues {
    Queue<Integer> Q1 = new LinkedList<>();
    Queue<Integer> Q2 = new LinkedList<>();

    // Push operation (costly)
    public void push(int x) {
        // Move all elements from Q1 to Q2
        while (!Q1.isEmpty()) {
            Q2.add(Q1.remove());
        }

        // Add new element to Q1
        Q1.add(x);

        // Move everything back from Q2 to Q1
        while (!Q2.isEmpty()) {
            Q1.add(Q2.remove());
        }
    }

    // Pop operation
    public int pop() {
        if (Q1.isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return Q1.remove(); // remove from front (which is top of stack)
    }

    // Peek operation
    public int top() {
        if (Q1.isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return Q1.peek();
    }

    public boolean isEmpty() {
        return Q1.isEmpty();
    }
}

public class Main {
    public static void main(String[] args) {
        StackUsingQueues stack = new StackUsingQueues();
        stack.push(10);
        stack.push(20);
        stack.push(30);

        System.out.println("Top: " + stack.top()); // 30
        System.out.println("Pop: " + stack.pop()); // 30
        System.out.println("Top after pop: " + stack.top()); // 20
    }
}

```