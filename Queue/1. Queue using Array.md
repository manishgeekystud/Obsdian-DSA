## **1. Concept Recap**

- A **Queue** is a linear data structure that follows **FIFO (First In First Out)**.
    
- Main operations:
    
    - **push(x)** → add element at **rear**.
        
    - **pop()** → remove element from **front**.
        

---

## **2. Why Array Implementation?**

- Simple and memory-efficient when size is fixed.
    
- Can be implemented using:
    
    - **Normal Array Queue** → wastes space after dequeues.
        
    - **Circular Queue** → reuses space by wrapping around (this code uses circular queue logic).
        

---

## **3. Structure**

The implementation maintains:

- **`arr[]`** → fixed-size array.
    
- **`start`** → points to the **front** element.
    
- **`end`** → points to the **rear** element.
    
- **`size`** → number of elements in the queue.
    
- **`capacity`** → max size of the queue.
    

---

## **4. Initialization**

`MyQueue() {    
start = 0;   // queue front 
end = -1;    // queue rear    
size = 0;    // current elements count
}`

---

## **5. Push Operation**

```java
void push(int x) { 
if (capacity == size) return; // queue full
end = (end + 1) % capacity;   // circular increment  
arr[end] = x;   
size++; 
}

```
✅ **Steps:**

1. Check if queue is full.
    
2. Increment `end` in a circular way using modulo `% capacity`.
    
3. Insert element at `arr[end]`.
    
4. Increase size.
    

**Time Complexity:** O(1)

---

## **6. Pop Operation**

```java
int pop() {     if (isEmpty()) return -1; // queue empty    
int item = arr[start];     
start = (start + 1) % capacity; // move front   
size--;     
return item; 
}

```
✅ **Steps:**

1. Check if queue is empty.
    
2. Store the front element.
    
3. Increment `start` in circular way.
    
4. Decrease size.
    
5. Return stored element.
    

**Time Complexity:** O(1)

---

## **7. Helper Method**

`boolean isEmpty() {     
return size == 0;
}`

---

## **8. Example Flow**

Initial: `start=0, end=-1, size=0`

### After `push(10), push(20), push(30)`

ini

CopyEdit

`arr = [10, 20, 30, ...] start = 0 end = 2 size = 3`

### After `pop()`

makefile

CopyEdit

`returns 10 start = 1 end = 2 size = 2 Queue now = [20, 30]`

---

## **9. Diagram (Circular Queue)**

pgsql

CopyEdit

`[ _ | _ | _ | _ | _ ]  capacity = 5  push(10): [10 | _ | _ | _ | _ ]  start=0, end=0 push(20): [10 | 20 | _ | _ | _ ] start=0, end=1 pop(): removes 10 -> start moves to 1 Now: [ _ | 20 | _ | _ | _ ] start=1, end=1`

---

## **10. Complexity Analysis**

|Operation|Time Complexity|Space Complexity|
|---|---|---|
|push|O(1)|O(n) (array size)|
|pop|O(1)|O(n)|
|isEmpty|O(1)|O(1)|

---

## **11. Key Takeaways**

- This is a **Circular Queue implementation** using array.
    
- `start` and `end` wrap around using modulo (`% capacity`).
    
- Full condition → `size == capacity`.
    
- Empty condition → `size == 0`.
    

---