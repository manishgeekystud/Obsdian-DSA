### Reverse first K of a Queue

Difficulty:Â **Easy**Accuracy:Â **81.28%**Submissions:Â **159K+**Points:Â **2**

Given an integerÂ **k**Â and aÂ [queue](http://www.geeksforgeeks.org/queue-data-structure/)Â of integers, we need to reverse the order of the firstÂ **k**Â elements of the queue, leaving the other elements in the same relative order.

Only following standard operations are allowed on queue.

- enqueue(x) : Add an item x to rear of queue
- dequeue() : Remove an item from front of queue
- size() : Returns number of elements in queue.
- front() : Finds front item.  
    

**Note:**Â The above operations represent the general processings. In-built functions of the respective languages can be used to solve the problem.

"If the size of queue is smaller than the given k , then return the original queue."

**Examples:**

**Input:** q = [1, 2, 3, 4, 5], k = 3  
**Output:** [3, 2, 1, 4, 5]  
**Explanation:** After reversing the first 3 elements from the given queue the resultant queue will be 3 2 1 4 5

**Input:** q = [4, 3, 2, 1], k = 4  
**Output:** [1, 2, 3, 4]   
**Explanation:** After reversing the first 4 elements from the given queue the resultant queue will be 1 2 3 4

---------------------------------------------------------------
## ğŸ› ï¸ Approach (Stack + Temp Queue)

1. Use a **stack** to reverse the order of the first `k` elements.
    
    - Pop from queue â†’ push into stack.
        
2. Use a **temporary queue** to store the remaining elements.
    
    - Keeps elements after `k` in correct order.
        
3. Push stack elements back into the original queue (reversed part).
    
4. Push temporary queue elements back (unchanged part).

**Code**
```java
public Queue<Integer> reverseFirstK(Queue<Integer> q, int k) {
    Stack<Integer> st = new Stack<>();
    Queue<Integer> temp = new LinkedList<>();
    int size = q.size();

    if (size >= k) {
        // Step 1: Move first k elements to stack
        for (int i = 0; i < size; i++) {
            if (i < k)
                st.push(q.remove());
            else if (!q.isEmpty())
                temp.add(q.remove());
        }

        // Step 2: Add back reversed k elements
        for (int i = 0; i < size; i++) {
            if (i < k)
                q.add(st.pop());
            else if (!q.isEmpty())
                q.add(temp.remove());
        }
    }
    return q;
}


```

# ğŸš€ Cleaner Approach (Interview Friendly)

### Idea:

1. Push first `k` elements into a stack â†’ they get reversed.
2. Pop from stack â†’ add back to queue â†’ reversed first `k`.
3. For the remaining `(n - k)` elements â†’ dequeue and enqueue again (rotation).



## â±ï¸ Complexity

- **Time Complexity** â†’ `O(n)` (all elements processed).
    
- **Space Complexity** â†’ `O(n)` (extra stack + temp queue).
    

---

## ğŸ“Š Example

Input:

`Queue = [10, 20, 30, 40, 50], k = 3`

Process:

- First 3 â†’ stack = [10, 20, 30]
    
- Remaining â†’ temp = [40, 50]  
 Result Queue:
`[30, 20, 10, 40, 50]`