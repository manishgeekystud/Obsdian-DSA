### Reverse first K of a Queue

Difficulty: **Easy**Accuracy: **81.28%**Submissions: **159K+**Points: **2**

Given an integer **k** and a [queue](http://www.geeksforgeeks.org/queue-data-structure/) of integers, we need to reverse the order of the first **k** elements of the queue, leaving the other elements in the same relative order.

Only following standard operations are allowed on queue.

- enqueue(x) : Add an item x to rear of queue
- dequeue() : Remove an item from front of queue
- size() : Returns number of elements in queue.
- front() : Finds front item.  
    

**Note:** The above operations represent the general processings. In-built functions of the respective languages can be used to solve the problem.

"If the size of queue is smaller than the given k , then return the original queue."

**Examples:**

**Input:** q = [1, 2, 3, 4, 5], k = 3  
**Output:** [3, 2, 1, 4, 5]  
**Explanation:** After reversing the first 3 elements from the given queue the resultant queue will be 3 2 1 4 5

**Input:** q = [4, 3, 2, 1], k = 4  
**Output:** [1, 2, 3, 4]   
**Explanation:** After reversing the first 4 elements from the given queue the resultant queue will be 1 2 3 4

---------------------------------------------------------------
## 🛠️ Approach (Stack + Temp Queue)

1. Use a **stack** to reverse the order of the first `k` elements.
    
    - Pop from queue → push into stack.
        
2. Use a **temporary queue** to store the remaining elements.
    
    - Keeps elements after `k` in correct order.
        
3. Push stack elements back into the original queue (reversed part).
    
4. Push temporary queue elements back (unchanged part).

**Code**
```java
public Queue<Integer> reverseFirstK(Queue<Integer> q, int k) {
    Stack<Integer> st = new Stack<>();
    Queue<Integer> temp = new LinkedList<>();
    int size = q.size();

    if (size >= k) {
        // Step 1: Move first k elements to stack
        for (int i = 0; i < size; i++) {
            if (i < k)
                st.push(q.remove());
            else if (!q.isEmpty())
                temp.add(q.remove());
        }

        // Step 2: Add back reversed k elements
        for (int i = 0; i < size; i++) {
            if (i < k)
                q.add(st.pop());
            else if (!q.isEmpty())
                q.add(temp.remove());
        }
    }
    return q;
}


```

# 🚀 Cleaner Approach (Interview Friendly)

### Idea:

1. Push first `k` elements into a stack → they get reversed.
2. Pop from stack → add back to queue → reversed first `k`.
3. For the remaining `(n - k)` elements → dequeue and enqueue again (rotation).



## ⏱️ Complexity

- **Time Complexity** → `O(n)` (all elements processed).
    
- **Space Complexity** → `O(n)` (extra stack + temp queue).
    

---

## 📊 Example

Input:

`Queue = [10, 20, 30, 40, 50], k = 3`

Process:

- First 3 → stack = [10, 20, 30]
    
- Remaining → temp = [40, 50]  
 Result Queue:
`[30, 20, 10, 40, 50]`