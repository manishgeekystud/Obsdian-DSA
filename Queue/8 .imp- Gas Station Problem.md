### Gas Station

Difficulty:Â **Medium**Accuracy:Â **34.79%**Submissions:Â **207K+**Points:Â **4**Average Time:Â **20m**

There are n gas stations along aÂ **circular tour**. You are given two integer arraysÂ **gas[]**Â andÂ **cost[]**, whereÂ **gas[i]**Â is the amount of gas available at stationÂ **i**Â andÂ **cost[i]**Â is the gas needed to travel from stationÂ **i**Â to station (**i+1**). You have a car with an unlimited gas tank and start with an empty tank at some station. Your task is to return theÂ **index**Â of the starting station if it is possible to travel once around the circular route in a clockwise direction without running out of gas at any station; otherwise, returnÂ **-1**.

**Note:**Â If a solution exists, it is guaranteed to be unique.

**Examples:**

**Input:** gas[] = [4, 5, 7, 4], cost[]= [6, 6, 3, 5]
**Output:** 2
**Explanation:** Start at gas station at index 2 and fill up with 7 units of gas. Your tank = 0 + 7 = 7  
Travel to station 3. Available gas = (7 â€“ 3 + 4) = 8.  
Travel to station 0. Available gas = (8 â€“ 5 + 4) = 7.  
Travel to station 1. Available gas = (7 â€“ 6 + 5) = 6.  
Return to station 2. Available gas = (6 â€“ 6) = 0.

**Input:** gas[] = [1, 2, 3, 4, 5], cost[] = [3, 4, 5, 1, 2]  
**Output:** 3
**Explanation:** Start at gas station at index 3 and fill up with 4 units of gas. Your tank = 0 + 4 = 4  
Travel to station 4. Available gas = 4 â€“ 1 + 5 = 8.  
Travel to station 0. Available gas = 8 â€“ 2 + 1 = 7.  
Travel to station 1. Available gas= 7 â€“ 3 + 2 = 6.  
Travel to station 2. Available gas = 6 â€“ 4 + 3 = 5.  
Travel to station 3. The cost is 5. The gas is just enough to travel back to station 3.

**Input:** gas[] = [3, 9], cost[] = [7, 6]  
**Output: -**1
**Explanation:** There is no gas station to start with such that you can complete the tour.

=============================================================

# ðŸš— Gas Station Problem â€” Interview Notes

### Problem Restatement

We are given:

- `gas[i]` â†’ amount of gas at station `i`.
    
- `cost[i]` â†’ gas required to travel from station `i` to `(i+1)`.
    

We need to return the **starting station index** from where we can complete a circular tour. If not possible â†’ return **-1**.

- If a solution exists, it is guaranteed to be **unique**.
    

---

## Step 1: Brute Force Idea

- Try each station as a starting point.
    
- Simulate the tour â†’ if fuel never goes negative, return that index.
    
- If none works â†’ return -1.
    

### code

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;

        // Try every station as a starting point
        for (int start = 0; start < n; start++) {
            int fuel = 0;
            boolean valid = true;

            // Simulate the full circle
            for (int i = 0; i < n; i++) {
                int idx = (start + i) % n; // wrap around circularly
                fuel += gas[idx] - cost[idx];
                if (fuel < 0) {
                    valid = false; // failed at some point
                    break;
                }
            }

            if (valid) return start; // found valid start
        }

        return -1; // no valid start
    }
}


```

### Complexity

- **Time:** O(nÂ²) â†’ too slow for large input.
    
- **Space:** O(1).
    

---

## Step 2: Key Observations

1. If `totalGas < totalCost` â†’ **impossible** to complete the tour.
    
2. If starting at `i` fails at station `j`, then **no station between `i` and `j` can work**.
    
    - Because fuel already went negative before reaching `j`.
        
    - So we can skip all those stations.
        

---

## Step 3: Greedy Optimized Approach

- Traverse stations once.
    
- Track `fuel = gas[i] - cost[i]` cumulatively.
    
- If fuel < 0:
    
    - Current start is invalid.
        
    - Move start to `i+1`.
        
    - Reset fuel = 0.
        
- At the end:
    
    - If `totalGas < totalCost` â†’ return -1.
        
    - Else return `start`.
        

---

## âœ… Final Java Solution (Optimized O(n))

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int totalGas = 0, totalCost = 0;
        int fuel = 0, start = 0;

        for (int i = 0; i < gas.length; i++) {
            totalGas += gas[i];
            totalCost += cost[i];
            fuel += gas[i] - cost[i];

            // If fuel goes negative, this start fails
            if (fuel < 0) {
                start = i + 1; // Next station as candidate
                fuel = 0;      // Reset fuel
            }
        }

        return (totalGas < totalCost) ? -1 : start;
    }
}

```

---

## Dry Run Example

### Input

`gas  = [4, 5, 7, 4] cost = [6, 6, 3, 5]`

### Walkthrough

- i=0: fuel = -2 â†’ fail â†’ new start = 1.
    
- i=1: fuel = -1 â†’ fail â†’ new start = 2.
    
- i=2: fuel = 4.
    
- i=3: fuel = 3.
    

Total gas = 20, total cost = 20 â†’ feasible.  
âœ… Answer = 2.

---

## Complexity Analysis

|Approach|Time|Space|Notes|
|---|---|---|---|
|Brute Force|O(nÂ²)|O(1)|Tries all starts|
|Greedy Optimized|O(n)|O(1)|âœ… Best choice|

---

## ðŸŽ¯ Interview Tips

- Start with brute force â†’ then optimize.
    
- Mention the key observation about skipping failed starts.
    
- Highlight the **totalGas < totalCost check** as an early exit.
    
- State the guarantee: **if a solution exists, itâ€™s unique**.