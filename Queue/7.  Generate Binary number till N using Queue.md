## 

Given a number **n**. The task is to generate all **binary numbers with decimal values** from **1 to n**.

**Examples:**

**Input:** n = 2
**Output:** ["1", "10"]
**Explanation:** Binary numbers from 1 to 2 are 1 and 10.

**Input:** n = 5
**Output:** ["1", "10", "11", "100", "101"]
**Explanation:** Binary numbers from 1 to 5 are 1 , 10 , 11 , 100 and 101.

-----------------------------------------------------------------------


💡 Key Idea

- Use a **queue of strings** to simulate a **Breadth-First Search (BFS)** like traversal.
- Start with `"1"`.
- For each number dequeued, generate its “children” by appending `"0"` and `"1"`.
- This ensures numbers are generated in correct binary order.
    

---

## ⚙️ Approach

1. Initialize a queue and enqueue `"1"`.
    
2. Loop `n` times:
    
    - Dequeue the front element → call it `current`.
        
    - Add `current` to the result list.
        
    - Enqueue `current + "0"` and `current + "1"`.
        
3. Return the result list after `n` iterations.
    

CODE

```java
 // Function to generate binary numbers from 1 to N using a queue.
    static ArrayList<String> generate(int n) {
        // Your code here
        Queue<String > q=new LinkedList<>();
        ArrayList<String> ar=new ArrayList<>();
        q.add("1");
      
        
        for(int i=0;i<n;i++)
        {
            String current=q.remove();
            ar.add(current);
            q.add(current+"0");
            q.add(current+"1");
        }
        
         return ar;
    }
```
---

## 🧩 Dry Run (n = 5)

Queue state changes step by step:

- Start: `["1"]`
    
- Pop `"1"`, add to result → enqueue `"10"`, `"11"` → Queue = `["10","11"]`
    
- Pop `"10"`, add to result → enqueue `"100"`, `"101"` → Queue = `["11","100","101"]`
    
- Pop `"11"`, add to result → enqueue `"110"`, `"111"` → Queue = `["100","101","110","111"]`
    
- Pop `"100"`, add to result → enqueue `"1000"`, `"1001"` → Queue = `["101","110","111","1000","1001"]`
    
- Pop `"101"`, add to result → stop (5 numbers generated).
    

✅ Result = `[1, 10, 11, 100, 101]`

---

## 📊 Complexity

- **Time Complexity**: `O(n)` → each element is enqueued/dequeued once.
    
- **Space Complexity**: `O(n)` → for storing result + queue elements.
    

---

## ✅ Interview Tip

- Clearly state the **analogy with BFS traversal**.
    
- Stress that using a **queue ensures order** of binary numbers.
    
- Show quick dry run to convince interviewer.