## **1. Recap**

- **Queue** â†’ FIFO (First In First Out)
    
    - Operations: `enqueue(x)`, `dequeue()`, `peek()`
        
- **Stack** â†’ LIFO (Last In First Out)
    
    - Operations: `push(x)`, `pop()`, `peek()`
        

ðŸ‘‰ Goal: Use **Stacks** to implement **Queue** behavior.

---

## **2. Approaches**

### **Approach 1: Two Stacks (Costly Enqueue)**

**Idea:**

- Always maintain the queue in correct order inside **stack1**.
    
- For `enqueue(x)`:
    
    1. Move all elements from `stack1 â†’ stack2`.
        
    2. Push new element into `stack1`.
        
    3. Move everything back from `stack2 â†’ stack1`.
        
- For `dequeue()` â†’ simply pop from `stack1`.
    

âœ… `enqueue()` = O(n)  
âœ… `dequeue()` = O(1)

---

### **Approach 2: Two Stacks (Costly Dequeue â€” Most Common)**

**Idea:**

- Use two stacks: **inStack** and **outStack**.
    
- For `enqueue(x)` â†’ push into `inStack`.
    
- For `dequeue()`:
    
    1. If `outStack` is empty, move all elements from `inStack â†’ outStack`.
        
    2. Pop from `outStack`.
        

âœ… `enqueue()` = O(1)  
âœ… `dequeue()` = Amortized O(1) (O(n) only when shifting happens)

---

### **Approach 3: Recursive (Single Stack)**

- Implement dequeue recursively using call stack.
    
- Less common in interviews â†’ focus more on Approach 2.
    

---

## **3. Diagram Example (Approach 2 â€” Costly Dequeue)**

Initial:

`inStack = [], outStack = []`

`enqueue(10)` â†’

`inStack = [10], outStack = []`

`enqueue(20)` â†’

`inStack = [10, 20], outStack = []`

`dequeue()` â†’ move all from inStack â†’ outStack, then pop

`inStack = [], outStack = [20, 10]`

returns **10** âœ… (FIFO).

---

## **4. Java Implementation**

### **Approach 1: Two Stacks (Costly Enqueue)**

```java
import java.util.Stack;

class QueueUsingStacks_CostlyEnqueue {
    Stack<Integer> s1 = new Stack<>();
    Stack<Integer> s2 = new Stack<>();

    // Enqueue operation (O(n))
    public void enqueue(int x) {
        // Move everything from s1 â†’ s2
        while (!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        // Push new element into s1
        s1.push(x);
        // Move everything back from s2 â†’ s1
        while (!s2.isEmpty()) {
            s1.push(s2.pop());
        }
    }

    // Dequeue operation (O(1))
    public int dequeue() {
        if (s1.isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }
        return s1.pop();
    }

    public int peek() {
        if (s1.isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }
        return s1.peek();
    }

    public boolean isEmpty() {
        return s1.isEmpty();
    }
}

```

---

### **Approach 2: Two Stacks (Costly Dequeue â€” Best Approach)**

```

```
---

## **5. Time Complexity Analysis**

|Approach|Enqueue|Dequeue|Space|
|---|---|---|---|
|Two Stacks (Costly Enqueue)|O(n)|O(1)|O(n)|
|Two Stacks (Costly Dequeue)|O(1)|Amortized O(1)|O(n)|

---

## **6. Key Takeaways**

- **Queue using Stacks** can be done with:
    
    - Costly `enqueue()` (O(n)) OR
        
    - Costly `dequeue()` (Amortized O(1), Best for practice).
        
- **Approach 2 (Costly Dequeue)** is the most efficient and commonly asked in interviews.
    
- Use **two stacks** (`inStack` and `outStack`) for clean implementation.